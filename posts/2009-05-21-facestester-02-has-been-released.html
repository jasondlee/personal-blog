---
title: 'FacesTester 0.2 Has Been Released'
author: 'Jason Lee'
layout: blog-post
date: 2009-5-21
tags: [ FacesTester, JavaServer Faces, jsf, Testing, Testing ]
---
<p>Today we released FacesTester 0.2.  While this release has a number of bug fixes and more minor enhancements, one of the biggest new features is injection support.<!--more-->  Leveraging the <code>InjectionProvider</code> Service Provider Interface (SPI) provided by Mojarra, FacesTester now supports the automagic injection of mock/test objects.  For example, the following managed bean:
</p>
<p>[source lang="java"]
</p>
<p>public class ManagedBeanWithJpa {
</p>
<p>    @PersistenceContext(unitName = "em")
</p>
<p>    private EntityManager entityManager;
</p>
<p>    public EntityManager getEntityManager() {
</p>
<p>        return entityManager;
</p>
<p>    }
</p>
<p>    public void setEntityManager(EntityManager entityManager) {
</p>
<p>        this.entityManager = entityManager;
</p>
<p>    }
</p>
<p>}
</p>
<p>[/source]
</p>
<p>can be tested like this:
</p>
<p>[source lang="java"]
</p>
<p>    @Test
</p>
<p>    public void shouldHaveInjectionPerformed() {
</p>
<p>        InjectionManager.registerObject("em", new MockEntityManager());
</p>
<p>        ManagedBeanWithJpa mb = tester.getManagedBean(ManagedBeanWithJpa.class, "jpaBean");
</p>
<p>        assertNotNull(mb.getEntityManager());
</p>
<p>    }
</p>
<p>[/source]
</p>
<p>In line 3 in the test code, we see the registration of our test <code>EntityManager</code>.  When JSF (Mojarra, in our FacesTester environment) creates the managed bean, it delegates to the <code>FacesTesterInjectionProvider</code>, when then injects <code>MockEntityManager</code> when it processes the <code>@PersistenceContext</code> annotation.  In a real test, one might create a test database using <a target="_blank" href="http://hsqldb.org/">HSQLDB</a> or <a target="_blank" href="http://db.apache.org/derby/">Derby</a> and <a target="_blank" href="http://dbunit.org">DBUnit</a>.
</p>
<p>Also in this release is code to test the state saving on a component.  A pretty common source of bugs with custom components is inadequate coverage in the state saving code.  FacesTester will examine the component and insure that each property is correctly handled:
</p>
<p>[source lang="java"]
</p>
<p>    @Test
</p>
<p>    public void testMyComponentStateSaving() {
</p>
<p>        FacesTester facesTester = new FacesTester();
</p>
<p>        facesTester.testStateSaving(MyComponentState.COMPONENT_TYPE);
</p>
<p>    }
</p>
<p>[/source]
</p>
<p>FacesTester will create the component using <code>Application.createComponent()</code>, populate each property with a test value, and save the state.  It will then create a new component of the same type and restore the saved state into this new component.  Finally, it iterates over each property, comparing the results of each getter.   If they don't match, an <code>Exception</code> is thrown.  Fancy! :)
</p>
<p>The <code>FacesConfig</code> object was also updated to cover more JSF artfiacts, so if you're using this aspect of the tool, be sure to checkout the updated JavaDocs for full details.
</p>
<p>As always, FacesTester is available in the java.net Maven repository:
</p>
<p>[source lang="xml"]
</p>
        <dependency>
            <groupId>com.steeplesoft.jsf</groupId>
            <artifactId>facestester</artifactId>
            <version>0.2</version>
            <scope>test</scope>
        </dependency>
<p>[/source]
</p>
<p>If you have any issues, please be sure to file issues <a target="_blank" href="http://kenai.com/jira/browse/FACESTESTER">here</a>.</p>
