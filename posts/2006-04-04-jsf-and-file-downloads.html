---
title: 'JSF and File Downloads'
author: 'Jason Lee'
layout: blog-post
date: 2006-4-4
tags: [ JavaServer Faces ]
---
<p>At <a target="_newwindow" href="http://www.iec-okc.com">IEC</a>, we have an application used to report inventory counts.  Part of the app creates an Excel spreadsheet using <a target="_newwindow" href="http://jakarta.apache.org/poi/">POI</a>.  The user selects a batch from a select/combo, click on the button, and the server sends them a spreadsheet.  The basic work flow is this:
pass::[more]
</p>
<ol>
<li>Display the page</li>
<li>User selects a batch and clicks the button</li>
<li>JSF calls the specified action on the backing</li>
<li>The backing bean creates the spreadsheet, then navigates to success.jsp, a plain ol' JSP</li>
<li>The JSP pulls the backing bean from the session, gets the workbook reference from it, and streams that to the user using a ServletOutputStream.</li>
</ol>
<p>This works well under Tomcat and JSF 1.1.  Our goal, though, is to migrate to a full JEE 5 environment, hosted on <a target="_newwindow" href="https://glassfish.dev.java.net">Glassfish</a>.  Glassfish, though, ships with JSF 1.2, as JSF is now part of the JEE spec (starting with version 5).  This poses a problem, though, as there has apparently been a good deal of work in view handling in 1.2 that breaks this behavior.  <a target="_newwindow" href="http://weblogs.java.net/blog/edburns/">Ed Burns</a> has been nice enough to take a look for me, but, while waiting for him to get time to help me, I took a stab at fixing it.  My tentative work around for it is as follows:
</p>
<ul>
<li>Alter the form to use a "normal" (read as: non-JSF) form and submit to a servlet.</li>
<li>Write a servlet that in effect duplicates the JSF lifecycle:
<ul><li>Build/load the FacesContext</li>
<li>Get a reference to the backing bean</li>
<li>Pull the batch id from the request and set it on the backing bean.</li>
<li>Call the action method.</li></ul></li>
</ul>
<p>At this point, the servlet works the same as the JSP:
</p>
<ul>
<li>Get the reference to the workbook</li>
<li>Stream the workbook to the user.</li>
</ul>
<p>This works, but is a pretty ugly hack.  In fact, check out the code:
</p>
<p>[source lang="java"]
</p>
<p>public class ExcelServlet extends HttpServlet {
</p>
<p>        /**
</p>
<p>         * If you examine FacesContext, you'll find that the setFacesContextAsCurrentInstance method is protected.
</p>
<p>         */
</p>
<p>        private abstract static class ProtectedFacesContext extends FacesContext {
</p>
<p>                protected static void setFacesContextAsCurrentInstance(FacesContext facesContext) {
</p>
<p>                        FacesContext.setCurrentInstance(facesContext);
</p>
<p>                }
</p>
<p>        }
</p>
<p>        public ExcelServlet() {
</p>
<p>                super();
</p>
<p>        }
</p>
<p>        @Override
</p>
<p>        public void doGet(HttpServletRequest request, HttpServletResponse response)
</p>
<p>                        throws ServletException, IOException {
</p>
<p>                this.getFacesContext(request, response);
</p>
<p>                BatchAuditReportBean report = (BatchAuditReportBean) FacesUtils.getManagedBean("batchAuditReportBean");
</p>
<p>                report.performTask();
</p>
<p>                org.apache.poi.hssf.usermodel.HSSFWorkbook workBook = report
</p>
<p>                                .getWorkBook();
</p>
<p>                ServletOutputStream sos;
</p>
<p>                try {
</p>
<p>                        response.setHeader("Cache-Control", "max-age=1");
</p>
<p>                        response.setHeader("Content-Disposition",
</p>
<p>                                        "attachment; filename=\"InventoryErrorReportServlet.xls\"");
</p>
<p>                        response.setContentType("application/vnd.ms-excel");
</p>
<p>                        sos = response.getOutputStream();
</p>
<p>                        workBook.write(sos);
</p>
<p>                        sos.flush();
</p>
<p>                } catch (IOException ioe) {
</p>
<p>                        System.out.println("IO Exception: " + ioe.toString());
</p>
<p>                }
</p>
<p>                response.getOutputStream().close();
</p>
<p>        }
</p>
<p>        private FacesContext getFacesContext(ServletRequest req,
</p>
<p>                        ServletResponse res) {
</p>
<p>                /** Try to get it first */
</p>
<p>                FacesContext facesContext = FacesContext.getCurrentInstance();
</p>
<p>                if (facesContext != null)
</p>
<p>                        return facesContext;
</p>
<p>                // Use the FactoryFinder to grab the Lifecycle object
</p>
<p>                FacesContextFactory contextFactory = (FacesContextFactory)
</p>
<p>                FactoryFinder.getFactory(FactoryFinder.FACES_CONTEXT_FACTORY);
</p>
<p>                LifecycleFactory lifecycleFactory = (LifecycleFactory)
</p>
<p>                FactoryFinder.getFactory(FactoryFinder.LIFECYCLE_FACTORY);
</p>
<p>                Lifecycle lifecycle =
</p>
<p>                        lifecycleFactory.getLifecycle(LifecycleFactory.DEFAULT_LIFECYCLE);
</p>
<p>                // Here's where the ProtectedFacesContext comes in
</p>
<p>                facesContext = contextFactory.getFacesContext(this.getServletContext(),
</p>
<p>                                req, res, lifecycle);
</p>
<p>                ProtectedFacesContext.setFacesContextAsCurrentInstance(facesContext);
</p>
<p>                return facesContext;
</p>
<p>        }
</p>
<p>}
</p>
<p>[/source]
</p>
<p>This code doesn't yet have the parameter fetching, but you can see how unattractive it is.  
</p>
<p>Hopefully, Ed will have a nicer fix for me.  Until then, I may have to put this monstrosity in production.</p>
