---
title: 'GlassFish Administration: The REST of the Story Part II - Deploying Apps Using Scala'
author: 'Jason Lee'
layout: blog-post
date: 2010-12-17
tags: [ administration, GlassFish, GlassFish, REST, REST, Scala, scala ]
---
<p>In a previous post (far too long ago :), I began showing off the RESTful administration API in GlassFish v3.  In <a href="/2010/08/glassfish-administration-the-rest-of-the-story/">GlassFish Administration: The REST of the Story Part I</a>, I showed the basics of the API, what to send, what you get back, etc.  In this post, I want to show a practical use of the API, namely, deploying an application, and this time, for no particular reason other than I'm trying to learn the language, we'll do it in Scala.<!--more-->
</p>
<p>If you'll recall from Part I, the default root URL is <a href="http://localhost:4848/management/domain">http://localhost:4848/management/domain</a>.  The endpoint, then for deploying applications works out to be <a href="http://localhost:4848/management/domain/applications/application">http://localhost:4848/management/domain/applications/application</a>.<sup>1</sup> Submitting an OPTIONS request to this endpoint gets us a document like this (trimmed down for clarity):
</p>
<p>[source]{
</p>
<p>     "extraProperties": {
</p>
<p>         "methods": [
</p>
<p>             {"name": "GET"},
</p>
<p>             {
</p>
<p>                 "name": "POST",
</p>
<p>                 "messageParameters": {
</p>
<p>                     "contextroot": {
</p>
<p>                         "acceptableValues": "",
</p>
<p>                         "optional": "true",
</p>
<p>                         "type": "string",
</p>
<p>                         "defaultValue": ""
</p>
<p>                     },
</p>
<p>                     "enabled": {
</p>
<p>                         "acceptableValues": "",
</p>
<p>                         "optional": "true",
</p>
<p>                         "type": "boolean",
</p>
<p>                         "defaultValue": ""
</p>
<p>                     },
</p>
<p>                     "force": {
</p>
<p>                         "acceptableValues": "",
</p>
<p>                         "optional": "true",
</p>
<p>                         "type": "boolean",
</p>
<p>                         "defaultValue": "false"
</p>
<p>                     },
</p>
<p>                     "id": {
</p>
<p>                         "acceptableValues": "",
</p>
<p>                         "optional": "false",
</p>
<p>                         "type": "class java.io.File",
</p>
<p>                         "defaultValue": ""
</p>
<p>                     },
</p>
<p>                     "name": {
</p>
<p>                         "acceptableValues": "",
</p>
<p>                         "optional": "true",
</p>
<p>                         "type": "string",
</p>
<p>                         "defaultValue": ""
</p>
<p>                     },
</p>
<p>                 }
</p>
<p>             }
</p>
<p>         ]
</p>
<p>     }
</p>
<p> }[/source]
</p>
<p>There are a lot of options there, but there are many more, giving you really fine-grained control over the deployment of your application.  In our case, we only care about a few options, which are in the list above:  <code>id</code>, <code>contextroot</code>, and <code>force</code>.  The <code>contextroot</code> option specifies the context root at which the application will be available, and <code>force</code> tells the server to redeploy the application if an existing app of the same name is already deployed.
</p>
<p>The id <code>parameter</code> is a bit different.  It's called id because of the way the REST Resource is implemented on the server side (i.e., the REST Resources wrap, more or less, various GlassFish CLI commands, pulling the required data in from the REST request, and handing if off to the appropriate AdminCommand instance.  It all boils down to a lot of internal GlassFish code that's outside the scope of this entry : ).  In our client code, we'll handle it as a String that represents the path to the archive to be deployed.  When we make the actual REST call (via the Jersey Client), we'll see that a File object is created as we pass the data to Jersey.
</p>
<p>Having already said too much, let's see some Scala code (for the Scala enthusiasts out there, this is, quite literally, the very first bit of Scala I've ever written, so be kind :):
</p>
<p>[scala]
</p>
<p>import com.sun.jersey.api.client.Client
</p>
<p>import com.sun.jersey.api.client.ClientResponse
</p>
<p>import com.sun.jersey.multipart.FormDataMultiPart
</p>
<p>import com.sun.jersey.multipart.file.FileDataBodyPart
</p>
<p>import javax.ws.rs.core.MediaType
</p>
<p>import java.io.File
</p>
<p>import scala.xml._
</p>
<p>object Main {
</p>
<p>  def main(args: Array[String]): Unit = {
</p>
<p>    val deployer = new GlassFishDeployer
</p>
<p>    deployer.deployApp("test.war");
</p>
<p>    deployer.applications foreach println 
</p>
<p>  }
</p>
<p>}
</p>
<p>object GlassFishDeployer {
</p>
<p>  val RESPONSE_TYPE = "application/xml"
</p>
<p>}
</p>
<p>class GlassFishDeployer {
</p>
<p>  val url = "http://localhost:4848/management/domain"
</p>
<p>  val client: Client = Client.create()
</p>
<p>  /**
</p>
<p>   * Get the management URLs for each deployed app
</p>
<p>   */
</p>
<p>  def applications: List[String] = {
</p>
<p>    var apps = List[String]()
</p>
<p>    val xml = XML.loadString(client.resource(url + "/applications/application")
</p>
<p>      .accept(GlassFishDeployer.RESPONSE_TYPE)
</p>
<p>      .get(classOf[String]))
</p>
<p>    for (entry <- ((xml \\ "entry" filter { node => (node \ "@key").text == "childResources" }) \ "map" \ "entry")) {
</p>
<p>      apps ::= entry.attributes("value").text
</p>
<p>    }
</p>
<p>    return apps
</p>
<p>  }
</p>
<p>  def deployApp(pathToArchive: String) = {
</p>
<p>    postWithUpload("/applications/application", Map[String, Any](
</p>
<p>      "id" -> new File(pathToArchive),
</p>
<p>      "contextroot" -> "testApp",
</p>
<p>      "force" -> "true"))
</p>
<p>  }
</p>
<p>  def postWithUpload(address: String, payload: Map[String, Any]) = {
</p>
<p>    val form = new FormDataMultiPart();
</p>
<p>    for ((key, value) <- payload) {
</p>
<p>      value match {
</p>
<p>        case x: File => form.getBodyParts().add((new FileDataBodyPart(key, value.asInstanceOf[File])))
</p>
<p>        case _ => form.field(key, value, MediaType.TEXT_PLAIN_TYPE)
</p>
<p>      }
</p>
<p>    }
</p>
<p>    client.resource(url + address)
</p>
<p>      .`type`(MediaType.MULTIPART_FORM_DATA)
</p>
<p>      .accept(GlassFishDeployer.RESPONSE_TYPE)
</p>
<p>      .post(classOf[ClientResponse], form)
</p>
<p>  }
</p>
<p>}[/scala]
</p>
<p>The two methods that are of interest here are <code>GlassFishDeployer.deployApp</code> and <code>GlassFishDeployer.postWithUpload</code>.  In the first, we build the map that holds all of the information we want to pass to the REST interface.  Of these three values, only <code>id</code> is required, for you minimalists out there.  In <code>postWithUpload</code>, we see the Jersey Client code.  We create a FormDataMultiPart object and populate it, then pass that to client as part of the chained calls at the end of the method.  There's no error handling here as that would obscure our objective here, but, barring something unforeseen, the test app should now be deployed.
</p>
<p>Back in the main method of Main, we make another call to the applications endpoint, which simply returns a list of application endpoints (for further management, such as undeploying) and prints each URL.
</p>
<p>That's all there is to it.  Using less-than-stellar Scala code, we've demonstrated how to deploy an application to a GlassFish instance.  Using the RESTful interface that shipped with v3, and which we continue to improve in 3.1, allows us to manage GlassFish from an application written in the language of our choice.
</p>
<p>The full project (including the Maven pom file), can be found <a href="/wp-content/uploads/2010/12/GlassFishDeployDemo.tar.gz">here</a>.
</p>
<hr/>
<sup>1</sup>You might look at that an wonder why it's "applications/application," and the answer is because the tree mimics the structure of the domain.xml file that is being manipulated via these endpoints.
