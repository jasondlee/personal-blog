---
title: 'GlassFish 3.1, REST, and Secure Admin'
author: 'Jason Lee'
layout: blog-post
date: 2011-2-17
tags: [ GlassFish, REST ]
---
<p>After posting my last entry, <a href="/2011/02/glassfish-3-1-rest-and-a-secured-admin-user/">GlassFish 3.1, REST, and a Secured Admin User,</a> I was asked about an entry on using GlassFish 3.1's REST interface with secure admin enabled.  Some of you may be asking, "Isn't that what you just wrote about?"  While the titles sound the same, they're slightly different, but in a very significant way.  Let's take a quick look at secure admin and then see what our REST client needs to do make use of this new server configuration.
pass::[more]
</p>
<p>Secure admin is defined as this in the <code>enable-secure-admin</code> help:
</p>
<div class="quote">
<p>The  enable-secure-admin  subcommand  creates  or   modifies secure-admin  and  secure-admin-principal elements under the domain element in the domain.xml for  the  domain.  Enabling secure  admin  affects  the entire domain, including the DAS and all instances.
</p>
<p>As part of this action, the  enable-secure-admin  subcommand performs the following functions:
</p>
<ul>
    <li>Sets the secure-admin enabled attribute to true  in domain.xml</li>
    <li>Adjusts all configurations in the domain, including default-config, and creates or updates secure-admin
        <ul>
            <li>If the secure-admin fragment already exists  in domain.xml,   then  the  alias  values  in  the secure-admin-principal  elements  are   changed only  if  the  --adminalias  or --instancealias options is specified  with  the  enable-secure-admin subcommand.</li>
            <li>The hidden  _instance-enable-secure-admin  sub-command  is  sent to all non-DAS targets in the domain. This hidden command performs  the  same configuration   changes  on  the  instances  as enable-secure-admin does on the DAS.</li>
        </ul>
    </li>
    <li>Creates the necessary truststore if it is missing
        <ul>
            <li>If the keystore and truststore do not contain a certificate  for  the  instance alias, then the instance self-signed key pair is generated  and the  private  key  is added to the keystore and the public certificate is added to  the  trust-store.</li>
            <li>If  the   truststore   does   not   contain   a certificate for the DAS alias, the DAS certificate from the keystore is added to  the  truststore.</li>
        </ul>
    </li>
    <li>Adjusts Grizzly settings
        <ul>
            <li>SSL/TLS  is  enabled  using  the  specified  --adminalias  value  in  the DAS's admin listener and the --instancealias value in the instances' admin listeners.</li>
            <li>Port  unification,  redirection,  and   client-auth=want are enabled.</li>
        </ul>
    </li>
</ul>
<p>A server restart  is  required  to  change  the  Grizzly adapter  behavior.  This also synchronizes the restarted instances that will deliver  any  updated  keystore  and truststore files.
</p>
</div>
<p>There's a lot to that, but all you <em>really</em> need to understand from the client's perspective is that you're going to have to use SSL. So... sorry to make you read all of that. :)
</p>
<p>First up, let's prepare the server:
</p>
<p>[source]
</p>
<p>$ asadmin enable-secure-admin
</p>
<p>$ asadmin stop-domain
</p>
<p>$ asadmin start-domain
</p>
<p>[/source]
</p>
<p>Unless you installed a signed certificate, if you run the example from my last post, you should now see a giant stack trace with <code>sun.security.validator.ValidatorException: PKIX path building failed</code> toward the end.  There are at least two ways to handle this.  The first, and perhaps the best, is simply to import the server's certificate.  One way to do this is via <a href="http://blogs.sun.com/andreas/resource/InstallCert.java">this utility</a> (written by a Sun engineer whose name I can't find):
</p>
<p>[source]
</p>
<p>$ javac InstallCert.java
</p>
<p>$ java InstallCert localhost
</p>
<p>[/source]
</p>
<p>Another approach, albeit riskier, is to accept all certificates.  You can achieve that with this code:
</p>
<p>[java]
</p>
<p>    public static void disableCertificateValidation() {
</p>
<p>        // Create a trust manager that does not validate certificate chains
</p>
<p>        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
</p>
<p>            @Override
</p>
<p>            public X509Certificate[] getAcceptedIssuers() {
</p>
<p>                return null;
</p>
<p>            }
</p>
<p>            @Override
</p>
<p>            public void checkClientTrusted(X509Certificate[] certs, String authType) {
</p>
<p>                return;
</p>
<p>            }
</p>
<p>            @Override
</p>
<p>            public void checkServerTrusted(X509Certificate[] certs, String authType) {
</p>
<p>                return;
</p>
<p>            }
</p>
<p>        }};
</p>
<p>        // Install the all-trusting trust manager
</p>
<p>        try {
</p>
<p>            SSLContext sc = SSLContext.getInstance("SSL");
</p>
<p>            sc.init(null, trustAllCerts, new SecureRandom());
</p>
<p>            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
</p>
<p>        } catch (Exception e) {
</p>
<p>        }
</p>
<p>    }
</p>
<p>[/java]
</p>
<p>Note that this will affect all HTTPS connections in the JVM, so use it with caution.  Once a call to that method has been added to the class' constructor, we can then change the GlassFish url to use HTTPS:
</p>
<p>[java]
</p>
<p>public class SslExample  {
</p>
<p>    private Client client;
</p>
<p>    public SslExample() throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException {
</p>
<p>        disableCertificateValidation();
</p>
<p>        client = Client.create();
</p>
<p>    }
</p>
<p>    public static void disableCertificateValidation() {
</p>
<p>        // Create a trust manager that does not validate certificate chains
</p>
<p>        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
</p>
<p>            @Override
</p>
<p>            public X509Certificate[] getAcceptedIssuers() {
</p>
<p>                return null;
</p>
<p>            }
</p>
<p>            @Override
</p>
<p>            public void checkClientTrusted(X509Certificate[] certs, String authType) {
</p>
<p>                return;
</p>
<p>            }
</p>
<p>            @Override
</p>
<p>            public void checkServerTrusted(X509Certificate[] certs, String authType) {
</p>
<p>                return;
</p>
<p>            }
</p>
<p>        }};
</p>
<p>        // Install the all-trusting trust manager
</p>
<p>        try {
</p>
<p>            SSLContext sc = SSLContext.getInstance("SSL");
</p>
<p>            sc.init(null, trustAllCerts, new SecureRandom());
</p>
<p>            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
</p>
<p>        } catch (Exception e) {
</p>
<p>        }
</p>
<p>    }
</p>
<p>    public boolean deployApp(String fileName) throws URISyntaxException {
</p>
<p>        FormDataMultiPart form = new FormDataMultiPart();
</p>
<p>        form.getBodyParts().add(new FileDataBodyPart("id", new File(fileName)));
</p>
<p>        form.field("name", fileName.substring(0, fileName.indexOf(".")), MediaType.TEXT_PLAIN_TYPE);
</p>
<p>        form.field("contextroot", fileName.substring(0, fileName.indexOf(".")), MediaType.TEXT_PLAIN_TYPE);
</p>
<p>        form.field("force", "true", MediaType.TEXT_PLAIN_TYPE);
</p>
<p>        ClientResponse response = client.resource("https://localhost:4848/management/domain/applications/application/")
</p>
<p>                .type(MediaType.MULTIPART_FORM_DATA)
</p>
<p>                .accept(MediaType.APPLICATION_JSON)
</p>
<p>                .post(ClientResponse.class, form);
</p>
<p>        return response.getStatus() == 200;
</p>
<p>    }
</p>
<p>    public static void main(String... args) {
</p>
<p>        try {
</p>
<p>            SslExample example = new SslExample();
</p>
<p>            if (example.deployApp(args[0])) {
</p>
<p>                System.out.println("Success");
</p>
<p>            } else {
</p>
<p>                System.out.println("Failure");
</p>
<p>            }
</p>
<p>        } catch (Exception e) {
</p>
<p>            e.printStackTrace();
</p>
<p>        }
</p>
<p>    }
</p>
<p>}
</p>
<p>[/java]
</p>
<p>There likely cleaner, safer ways of going about this, but this will certainly get you going.</p>
