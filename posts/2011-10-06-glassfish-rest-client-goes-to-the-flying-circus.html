---
title: 'GlassFish REST Client Goes to the Flying Circus'
author: 'Jason Lee'
layout: blog-post
date: 2011-10-6
tags: [ GlassFish, Java, Python, REST ]
---
<p>It happened a bit more quickly than I had planned, and, yes, I know that's a pretty bad Python joke, but, as <a href="/2011/10/glassfish-rest-interface-a-client-side-perspective/">promised</a>, I just committed code to add support for generating Python REST clients to the GlassFish RESTful Administration interface. Let's take a quick look at it.
pass::[more]
</p>
<h3>One easy egg to crack!</h3>
<p>Generating the python client looks strangely similar to how it's done for java:
</p>
<p>[source]
</p>
<p>asadmin generate-rest-client --languages python --outputdir tmp
</p>
<p>[/source]
</p>
<p>After that is complete, you'll have a Python egg in <code>tmp/</code> that you can then install into your Python environment:
</p>
<p>[source]
</p>
<p>sudo easy_install tmp/glassfish-rest-client-stubs.zip
</p>
<p>[/source]
</p>
<p>If you want both the Java and Python stubs, the command line would look like this:
</p>
<p>[source]
</p>
<p>asadmin generate-rest-client --languages java,python --outputdir tmp
</p>
<p>[/source]
</p>
<h3>Great! How do I use it?</h3>
<p>To show how similar the clients are, I'm going to implement here, in Python, the same examples I gave in <a href="/2011/10/glassfish-rest-interface-a-client-side-perspective/">my last post</a>.  First up, then, is creating a JDBC connection pool:
</p>
<p>[python]
</p>
<p>from glassfish.rest import *
</p>
<p>restClient = RestClient()
</p>
<p>domain = restClient.getDomain()
</p>
<p>resources = domain.getResources();
</p>
<p>cp = resources.getJdbcConnectionPool(&quot;TestPool&quot;)
</p>
<p>if cp:
</p>
<p>    # The get method will return null if the requested resource does not exist
</p>
<p>    cp.delete()
</p>
<p>rr = resources.createJdbcConnectionPool(&quot;TestPool&quot;, {
</p>
<p>    &quot;restype&quot;: &quot;javax.sql.XADataSource&quot;,
</p>
<p>    &quot;datasourceclassname&quot;: &quot;org.apache.derby.jdbc.ClientDataSource&quot;,
</p>
<p>    &quot;property&quot;: &quot;portNumber=1527:password=APP:user=APP:serverName=localhost:databaseName=sun-appserv-samples&quot;
</p>
<p>})
</p>
<p>print &quot;Success!&quot; if rr.isSuccess() else (&quot;Failure: &quot; + rr.getMessage())
</p>
<p>[/python]
</p>
<p>Easy! Now let's deploy an application:
</p>
<p>[python]
</p>
<p>from glassfish.rest import *
</p>
<p>restClient = RestClient()
</p>
<p>domain = restClient.getDomain()
</p>
<p>rr = domain.getApplications().deploy(open(&quot;test.war&quot;), {'force':True})
</p>
<p>print &quot;Success!&quot; if rr.isSuccess() else (&quot;Failure: &quot; + rr.getMessage())
</p>
<p>[/python]
</p>
<p>Undeploying is just as easy:
</p>
<p>[python]
</p>
<p>app = domain.getApplications().getApplication(&quot;test&quot;)
</p>
<p>if app:
</p>
<p>    app.delete();
</p>
<p>[/python]
</p>
<h3>Final Word</h3>
<p>In theory, the Python API should look just like the Java API.  The goal is to provide, as nearly as possible, identical experiences with the client API, regardless of the target language.  That certainly opens the door to complaints that this code isn't as "pythonic" as it should (which may or may not be the case. I'm not good enough with Python to tell you one way or the other ; ). It also means that any API warts the Java version has will be present in the other languages.  The goal, then, is to fix whatever issues the Java version may have and let that trickle down to the other language(s).  That means that if you have any issues, now's the time to speak.  Good or bad, I'd love to hear your thoughts.</p>
